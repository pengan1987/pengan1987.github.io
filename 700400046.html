<html><head><title>在中国接入互联网30周年之时，搭一台1994年的Linux服务器（上）</title></head><body><h1>在中国接入互联网30周年之时，搭一台1994年的Linux服务器（上）</h1><p>作者：蓬岸 Dr.Quest<br>知乎文章编号：700400046<br>创建于：2024-05-29 1:28:38<br>修改于：2024-06-06 4:30:25</p><hr><p data-pid="5CjMOzqe">从1994年4月中国接入互联网（开通TCP/IP路由）至今已经整整30年了，其中由中科院高能所设立的中国第一台WWW服务器，即<a href="http://ihep.ac.cn" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">ihep.ac.cn</span><span class="invisible"></span></a>曾经使用过的第一台服务器是最常被提起的服务器设备之一。</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-6aac57beaf54a91f8f2f77de2df596a4_b.jpg" data-size="normal" data-rawwidth="500" data-rawheight="375" class="origin_image zh-lightbox-thumb" width="500" data-original="https://pic1.zhimg.com/v2-6aac57beaf54a91f8f2f77de2df596a4_r.jpg" data-original-token="v2-6aac57beaf54a91f8f2f77de2df596a4"/><figcaption>图片来自：http://www.ihep.cas.cn/zt/bepc30/jnwz/zwxd/201810/t20181015_5142417.html</figcaption></figure><p data-pid="j_nBED5N">但几乎在所有回顾文章中，关于这台服务器的信息都只是一句简单的“运行在486上的Linux”，但当时的Linux究竟是什么样子，配置和运行它又有哪些挑战？这激发了我极大的好奇心。</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-e1a74a573adb8c4c7fce810d9d88b78e_b.jpg" data-caption="" data-size="normal" data-rawwidth="553" data-rawheight="612" class="origin_image zh-lightbox-thumb" width="553" data-original="https://pic3.zhimg.com/v2-e1a74a573adb8c4c7fce810d9d88b78e_r.jpg" data-original-token="v2-e1a74a573adb8c4c7fce810d9d88b78e"/></figure><p data-pid="5gRgIYf6">这是早期的IHEP网站唯一一张截图，从图中我们可以很容易看出，使用的浏览器的NCSA Mosaic，而熟悉早期Linux的朋友们可能能辨识出它使用的窗口管理器是FVWM。</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-046bdb9936a583556570244bd960d670_b.jpg" data-caption="" data-size="normal" data-rawwidth="1080" data-rawheight="593" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-046bdb9936a583556570244bd960d670_r.jpg" data-original-token="v2-046bdb9936a583556570244bd960d670"/></figure><p data-pid="HftIdyDd">在如此有限的技术信息下试图复原中科院高能所当年的Web服务器显然很难做到完全准确，在《计算机六十年》公众号文章《<a href="https://mp.weixin.qq.com/s/69bFEhQjycbZe-ruLLVFrQ" class=" wrap external" target="_blank" rel="nofollow noreferrer">许榕生：从66届到互联网第一人</a>》中，拍摄了高能所目前展示的情况：486电脑上运行着Windows 95。在我看来，这样的展示仅完成了一半，因为<b>以计算机作为历史上下文的展览里软件和硬件同样重要</b>。我希望能够通过实验考古的手段，搭建一套接近当时真实情况的软件环境，解析在当时和现在运行它们可能遇到的挑战，并展现90年代初使用Linux作为Internet服务器的情况。</p><h2>Linux内核1.0和SLS</h2><p data-pid="dFbWaJZ0">由于没有任何文章提到当时高能所使用的Linux发行版，因此我只能以“从近”和“从广”两个角度来选择，以1994年4~5月间，较新而且容易获得的发行版为基础。</p><p data-pid="mrK-8Qk2">一个最明显的信息是1994年3月Linux 1.0发布。而发行版上，最有可能的选项有两个Softlanding Linux System 1.0.5（1994年4月5日），和Slackware 1.2.0.1（1994年4月1日）。</p><p data-pid="tsxRMTaz">在实际尝试了这两个发行版后，我选择了Softlanding Linux System，通常被称作“SLS”，一个原因是它的容量更小，如果是需要33张软盘，而完整的Slackware需要60张！同时它也更易于安装，在Slackware的安装过程中需要用户选择所需要的安装包，在几乎没有包依赖管理的当时，很容易漏装某些依赖项而导致安装的程序不能用，而SLS则提供“一键安装”选项。</p><p data-pid="T7Bt3V5J">在Linux世界中，易用性几乎从第一天开始就是一个重大挑战，以“Gentle Touchdowns for DOS Bailouts”为口号的SLS以易用性的优势成为当时最流行的Linux发行版，类似于今天Ubuntu的地位。</p><blockquote data-pid="5RbyGysx">Gentle Touchdowns for DOS Bailouts直译成中文非常拗口，“DOS救援的温柔着陆”，touchdown是美式橄榄球的得分动作，对中国读者来说很陌生，bailout这个词作为“救助”则偏大，常用与国家或机构之间的经济援助，这句话大致可以翻译为“为DOS用户提供温柔着陆的救援方案”。</blockquote><p data-pid="e4kIikgU">最后一个不算成立的理由，是对我个人而言，SLS在地理上是最近的，其开发者Peter MacDonald住在加拿大西端温哥华岛上的维多利亚，而我住在温哥华，这两个城市的轮渡只需一个半小时，而我自己的电话区号和SLS是相同的。</p><p data-pid="SvfKGIEA">当然，Softlanding Linux System远非完美，甚至在当年就因为bug多而引发诸多不满，1993年夏天，Patrick Volkerding不满SLS的诸多bug，在修改后重新打包并以Slackware为名发行。因此，SLS也曾是Slackware的“上游”。</p><h2>安装SLS</h2><p data-pid="5VqRJumy">类似于<a href="https://zhuanlan.zhihu.com/p/697953965" class="internal">《重现WWW的起源（上）：安装并配置X86版NeXTSTEP 3.3》</a>，这篇文章一方面服务于对Linux和Internet历史感兴趣的个人爱好者，另一方面也服务于希望重现历史场景的科技馆等公共展示空间，因此我使用86Box模拟器作为我的主要环境的同时，同样会严谨考量安装完成后的硬盘镜像考虑写入储存卡并在真实硬件上运行的可行性。</p><p data-pid="GRw7l-4X">由于SLS在当时很流行，近年来复古计算社区尝试重现努力并不算少，我至少能够找到3~4篇不同语言介绍SLS安装的文章：</p><p data-pid="5zJP74aH"><a href="https://linux.cn/article-8836-1.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Linux 1.0 之旅：回顾这一切的开始</a>（中文）</p><p data-pid="sspvwi1C"><a href="https://casadevall.pro/articles/2020/06/softlanding-linux-system-1.0.5/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Softlanding Linux System 1.0.5</a>（英文，来自NCommander） </p><p data-pid="b8G1qUy6"><a href="https://www.os-museum.com/linux/sls105/sls105.htm" class=" wrap external" target="_blank" rel="nofollow noreferrer">オープンギャラリー：SLS 1.05</a> （日文，来自OS Museum）</p><p data-pid="8i5RczKc">sourceforge上有一个完整的tar包，<a href="https://sourceforge.net/projects/archiveos/files/s/sls/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Browse /s/sls at SourceForge.net</a></p><p data-pid="5jLIR_QM">其中的文件名都是符合DOS 8.3格式的，因此不用担心它在Windows上解压的问题，压缩包中a1.3，a1.5是3.5寸和5.25寸启动盘的镜像，将扩展名改为.img就可以在大部分虚拟机加载；而以a/b/c/d/s/t/x等编号的文件夹是为软盘安装组织的，每个文件夹对应一张软盘。</p><h3>硬盘和BIOS设置</h3><p data-pid="LHVSR-3g">但即使看过上面的文章，我仍然踩到一些坑，下面整理出来：</p><ol><li data-pid="Z3IHmSuh">用软盘安装很慢，30多张盘，可以从硬盘或光盘安装，通常是将所有安装文件夹放在磁盘根目录的/install下</li><li data-pid="dhs0mAsa">1994年的Linux 1.0不支持IDE光驱（ATAPI标准在当年才提出），建议以第二块虚拟硬盘安装</li><li data-pid="aSWOsO-N">1994年的Linux 1.0不支持LBA，但支持超过1024柱面的硬盘，使用540MB以上硬盘需要关闭BIOS的LBA选项，这导致DOS兼容问题</li><li data-pid="pLggO1Qk">1994年的Linux 1.0不完整支持Intel 430FX或更新芯片组上使用的EIDE Dual Channel控制器，这会导致只有Primary Master/Slave硬盘被识别，而Secondary Master/Slave不被识别</li><li data-pid="akVn7G9G">SLS的安装程序会把Lilo安装到PBR（分区引导记录）而非MBR（主引导记录），需要在安装完成后第一次使用软盘启动，并修复Lilo配置（NCommander文章中有提到）</li></ol><p data-pid="YNJlu7-K">由于上面第2点，我为从硬盘安装创建了两个磁盘镜像，一个900M用来模拟1GB储存卡，一个100M用来作系统安装源，由于上面的第4点，硬盘需要配置为0:0和0:1，即Primary Master/Slave。</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-600401fab5027869d90ab5802c435c96_b.jpg" data-caption="" data-size="normal" data-rawwidth="1041" data-rawheight="777" class="origin_image zh-lightbox-thumb" width="1041" data-original="https://pic3.zhimg.com/v2-600401fab5027869d90ab5802c435c96_r.jpg" data-original-token="v2-600401fab5027869d90ab5802c435c96"/></figure><p data-pid="-4YD8gi-">此外由于上面第3点，BIOS中硬盘要选NORMAL模式，而不能用LBA</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-f6c782f144a435c872930dc92691da16_b.jpg" data-caption="" data-size="normal" data-rawwidth="720" data-rawheight="400" class="origin_image zh-lightbox-thumb" width="720" data-original="https://pic3.zhimg.com/v2-f6c782f144a435c872930dc92691da16_r.jpg" data-original-token="v2-f6c782f144a435c872930dc92691da16"/></figure><p data-pid="ERDCM09z">AMI BIOS的例子，LBA Mode要选Off，不然会导致无法挂载根目录而导致Kernel Panic</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-dd8270bf1f86be2988bc4c6dbfdc73f2_b.jpg" data-caption="" data-size="normal" data-rawwidth="640" data-rawheight="350" class="origin_image zh-lightbox-thumb" width="640" data-original="https://pic3.zhimg.com/v2-dd8270bf1f86be2988bc4c6dbfdc73f2_r.jpg" data-original-token="v2-dd8270bf1f86be2988bc4c6dbfdc73f2"/></figure><p data-pid="Z3evVHh2">由于上面第1点，使用WinImage或类似的工具将安装盘目录放install目录中</p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-305e54a8ebb5e68ea5176a3318f56663_b.jpg" data-caption="" data-size="normal" data-rawwidth="910" data-rawheight="746" class="origin_image zh-lightbox-thumb" width="910" data-original="https://pic4.zhimg.com/v2-305e54a8ebb5e68ea5176a3318f56663_r.jpg" data-original-token="v2-305e54a8ebb5e68ea5176a3318f56663"/></figure><p data-pid="ViTaQHbr">只要硬盘设置正确，只要有8M以上内存，从386SX到Socket 370级别的机器都可以安装完成。但由于上面第5点，我们第一次启动仍然需要通过在安装过程中创建的安装盘完成，之后才能设置lilo。</p><p data-pid="h1qClraL">使用vi编辑器修改/etc/lilo.conf，第一行 boot=/dev/hda1 就是Lilo被写入PBR的罪魁祸首，要改为 boot=/dev/hda才可以将Lilo写入MBR。（以下lilo.conf样例仅供参考）</p><div class="highlight"><pre><code class="language-text">boot = /dev/hda
install = /boot/boot.b
delay = 50
#vga=ask
image = /zImage
        label = linux
        read-only
        root = /dev/hda1
image = /Image
        label = linux2
        read-only
        root = /dev/hda1</code></pre></div><p data-pid="RGmyTv98">delay和vga两行可以注释掉，这样Lilo不会等待输入启动参数或者提视选择文本显示模式，可以加快启动速度，修改完lilo.conf之后，使用lilo命令将其写入硬盘，之后就可以启动了。</p><h3>配置交换分区/文件</h3><p data-pid="cLJlMX6Q">对于1994年的486电脑来说，内存普遍只有8M甚至4M，因此swap分区几乎是不可或缺的，不然在编译程序或执行X-Window时很容易因为内存不足而导致程序崩溃。</p><p data-pid="NOMZS80O">今天标准的Linux安装通常会创建一个swap分区，在当时也可以这样做，比如下面的截图里，就有一个50MB的swap分区/dev/hda2</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-c266e46de396b3d364c0f9b9c031c595_b.jpg" data-caption="" data-size="normal" data-rawwidth="720" data-rawheight="400" class="origin_image zh-lightbox-thumb" width="720" data-original="https://pic2.zhimg.com/v2-c266e46de396b3d364c0f9b9c031c595_r.jpg" data-original-token="v2-c266e46de396b3d364c0f9b9c031c595"/></figure><p data-pid="W4vw_xOR">接下来我们就可以使用mkswap将其设置为swap分区，并用swapon命令挂载它，由于当时的mkswap程序无法自动识别分区容量，所以必须手工提供分区容量参数，见FreeBSD提供的Red Hat 4.2的manpage：<a href="https://man.freebsd.org/cgi/man.cgi?query=mkswap&manpath=Red+Hat+4.2" class=" wrap external" target="_blank" rel="nofollow noreferrer">mkswap</a></p><div class="highlight"><pre><code class="language-bash"><span class="c1">#查看分区尺寸</span>
fdisk -l
<span class="c1">#根据分区尺寸创建swap</span>
mkswap /dev/hda2 <span class="m">50904</span>
<span class="c1">#挂载交换分区</span>
swapon /dev/hda2
<span class="c1">#查看可用内存</span>
free</code></pre></div><p data-pid="HA40YJD8">如果你没有在安装系统时创建交换分区，硬盘上也没有额外的空间了，则可以创建一个交换文件</p><div class="highlight"><pre><code class="language-bash"><span class="c1">#创建16MB的空白文件/swapfile作为交换文件</span>
dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/swapfile <span class="nv">bs</span><span class="o">=</span><span class="m">1024</span> <span class="nv">count</span><span class="o">=</span><span class="m">16384</span>
mkswap /swapfile <span class="m">16384</span>
<span class="c1">#等待硬盘写入完成</span>
sync
<span class="c1">#启用交换文件</span>
swapon swapfile
free</code></pre></div><p data-pid="MG4t0MTS">最后，你可以将交换分区设置写入到/etc/fstab里，每次系统启动就会自动启用交换区了。（以下fstab文件供参考）</p><div class="highlight"><pre><code class="language-text">/dev/hda1       /               ext2    defaults
/dev/hda2       none            swap    defaults
none    /proc   proc    defaults</code></pre></div><h3>配置网卡</h3><p data-pid="b5a2o5IO">由于Linux流行之初就被广泛用作便宜的Unix网络工作站和服务器，因此其网络支持相对完善，但仍然有一些需要注意的：</p><ol><li data-pid="uj-zZfBu">不要指望PCI或PnP支持，PCI插槽在1994年下半年才进入市场，Linux在当时作为爱好者的操作系统，不可能提前获得厂商的硬件支持</li><li data-pid="TSO9maQ1">mcd（Mitsumi CD-ROM）驱动程序会尝试占用I/O地址0x300，可能会干扰一些网卡的运行</li><li data-pid="tN17Xw8n">SLS的网络配置习惯和今天不同，比如/etc/hosts同时包含了主机和路由的设置</li></ol><p data-pid="upCUv5C3">作为参考，我建议快速阅览Linux 1.0的网络驱动源码：<a href="https://github.com/kalamangga-net/linux-1.0/tree/master/drivers/net" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/kalamangga-n</span><span class="invisible">et/linux-1.0/tree/master/drivers/net</span><span class="ellipsis"></span></a></p><p data-pid="NubjN-fI">以及Slackware 3.0的Ethernet How-To：<a href="http://slackware.cs.utah.edu/pub/slackware/slackware-3.0/docs/Ethernet-HOWTO" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">slackware.cs.utah.edu/p</span><span class="invisible">ub/slackware/slackware-3.0/docs/Ethernet-HOWTO</span><span class="ellipsis"></span></a></p><p data-pid="n92tvNl6">Ethernet How-To这份文件略新，但仍然能覆盖我们遇到的一些问题，比如问题2就可以通过搜索“mcd=”或“ether=”找到错开I/O地址请求的方法。</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-b2a753ea6919b08883a6ec898cefa866_b.jpg" data-size="normal" data-rawwidth="1200" data-rawheight="675" class="origin_image zh-lightbox-thumb" width="1200" data-original="https://pic3.zhimg.com/v2-b2a753ea6919b08883a6ec898cefa866_r.jpg" data-original-token="v2-b2a753ea6919b08883a6ec898cefa866"/><figcaption>图中的声卡搭载了松下和Mitsumi的光驱接口，PCB上预留了索尼接口的焊点，但没有安装</figcaption></figure><p data-pid="GMv5nP82">补充一点ATAPI之前光驱的情况，1995年之前，除了存在使用SCSI接口的光驱之外，数种搭载在声卡上的光驱接口，它们和配套的光驱组成当时常见的“多媒体个人电脑（MPC）套件”，有时这些接口也被称作“AT接口”。其中最常见的是索尼、松下和Mitsumi（三美电机，90年代电脑市场多称“米苏米”）。</p><p data-pid="AvVC_oSl">国内常见的D-Link DE220、Realtek 8019、Accton等ISA PnP NE2000卡应该都可以支持，但需要DOS启动盘和软跳线配置程序将其设置为非PnP模式并固定I/O Address和IRQ选项</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-ff8a9f227bbd2ca9b445eb542aa8e1c6_b.jpg" data-size="normal" data-rawwidth="1024" data-rawheight="768" class="origin_image zh-lightbox-thumb" width="1024" data-original="https://pic3.zhimg.com/v2-ff8a9f227bbd2ca9b445eb542aa8e1c6_r.jpg" data-original-token="v2-ff8a9f227bbd2ca9b445eb542aa8e1c6"/><figcaption>RSET8019可以修改Realtek 8019的I/O地址，IRQ等参数，对于Book8088这类不支持PnP的设备也是必须的</figcaption></figure><p data-pid="3IAzkKOp">如果网卡识别正常，在系统启动过程中就可以看到提示的信息，在下面的截图中我们可以看到/etc/<a href="http://rc.net" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">rc.net</span><span class="invisible"></span></a>在尝试启动TCP/IP</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-2f54277be3cdddccde027ce60cd3b941_b.jpg" data-caption="" data-size="normal" data-rawwidth="720" data-rawheight="400" class="origin_image zh-lightbox-thumb" width="720" data-original="https://pic2.zhimg.com/v2-2f54277be3cdddccde027ce60cd3b941_r.jpg" data-original-token="v2-2f54277be3cdddccde027ce60cd3b941"/></figure><p data-pid="JUrEp_uq">接下来我们可以配置TCP/IP了，首先我们列一个工作清单</p><ul><li data-pid="1GtNytm7">主机名（比如softland）</li><li data-pid="an6Uj6XS">IP地址（比如192.168.1.29）</li><li data-pid="EoOEGueg">网络地址（通常是IP地址，以0结尾，如192.168.1.0）</li><li data-pid="1vEd3wWx">路由器（比如192.168.1.254）</li><li data-pid="AFwkjg0K">DNS（许多时候和路由器相同，有些时候也可以设置为外部的公共DNS）</li></ul><p data-pid="JUxRfaSc">主机名一共要修改两处，都改成上面列出的主机名：</p><ul><li data-pid="oW7Xzg8x">/etc/HOSTNAME</li><li data-pid="EAcB19fZ">/etc/host</li></ul><p data-pid="yQMIGacE">默认安装的主机名会有后缀<a href="http://softlanding.com" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">softlanding.com</span><span class="invisible"></span></a>，请删去。此外/etc/resolv.conf也要删除domain一行，只保留nameserver指向DNS服务器，设置好之后用cat命令检查文件内容，（以下文本截取自终端输出）</p><div class="highlight"><pre><code class="language-text">1:softland:/$ cat /etc/HOSTNAME
softland
1:softland:/$ cat /etc/host
softland
1:softland:/$ cat /etc/resolv.conf
nameserver 192.168.1.254</code></pre></div><p data-pid="1dPE3xiJ">由于前面列出的原因3，IP地址、网关等设置需要在/etc/hosts里设置，注意IP地址和名称之间以制表符分隔，只用空格的话/etc/<a href="http://rc.net" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">http://</span><span class="visible">rc.net</span><span class="invisible"></span></a>无法正常处理</p><div class="highlight"><pre><code class="language-text">#以下文本截取自我的/etc/hosts，请根据自己的网络状况进行调整
# Local Hosts Format:
#  IP_NUMBER            HOSTNAME        ALIASES
#
# Here is the name of your host, first, followed by any aliases
192.168.1.29            softland
#
# Your network number (usually same as above, with last number zero)
192.168.1.0             network
#
# Uncomment and define IP number of router if not on isolated network.
192.168.1.254                   router
#
# Local host ip num: no need to change this.
127.0.0.1               localhost
#</code></pre></div><p data-pid="V4QgeG8z">修改完这些文件，重启之后，就可以访问TCP/IP网络了，SLS已经内置了FTP客户端，可以作为和外接交换数据的窗口</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-2c3cbfa7ddf5f371d305215fa54cbe6d_b.jpg" data-caption="" data-size="normal" data-rawwidth="720" data-rawheight="400" class="origin_image zh-lightbox-thumb" width="720" data-original="https://pic2.zhimg.com/v2-2c3cbfa7ddf5f371d305215fa54cbe6d_r.jpg" data-original-token="v2-2c3cbfa7ddf5f371d305215fa54cbe6d"/></figure><h2>体验基本的Internet服务器</h2><p data-pid="OOJRiiyR">默认安装的SLS自带了FTP、Telnet、UUCP、电子邮件等服务器，可以说，除了没有WWW、Gopher等信息查询服务，它已经是一台完整的Internet服务器了，具体开放的服务可以在/etc/inetd.conf中看到</p><h3>FTP和Telnet</h3><p data-pid="RnOYpIDn">Telnet不用多说，在今天，加密的SSH取代了它的地位，FTP文件传输协议则是当时最重要的Internet服务——当时的Linux本身在互联网上就是依靠FTP传播的。SLS中的FTP跟FileZilla这样的现代FTP客户端连接会有些问题，但Windows下的FTP命令是没问题的，关于FTP命令的用法，可以参考：<a href="https://blog.csdn.net/newbie_907486852/article/details/79352217" class=" wrap external" target="_blank" rel="nofollow noreferrer">CMD中FTP命令大全_cmd ftp命令-CSDN博客</a></p><p data-pid="LoC9gpYE">在SLS中，默认的FTP根目录是/user/ftp，支持匿名访问。</p><h3>古老的Finger协议</h3><p data-pid="NJaxJq-U">在SLS上，我们可以体验另一个在教科书上不断出现而今天基本不再使用的协议：Finger</p><a href="https://baike.baidu.com/item/Finger/2474497" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-a18848aba0310f4ffc96ff87bfd79339_l.jpg" data-image-width="350" data-image-height="350" class=" wrap external" target="_blank" rel="nofollow noreferrer">Finger</a><p data-pid="olYX1ufI">我们在Windows机器上用Finger命令查询SLS，大概会得到如下结果：</p><div class="highlight"><pre><code class="language-text">C:\Users\Andy&gt;finger @192.168.1.29

[192.168.1.29:79]
Login    Name                 Tty  Idle  Login Time   Office     Office Phone
andy     Andy Zhou             p0        May 29 12:08 321        777-888-9999
root                           1     10  May 29 11:50


C:\Users\Andy&gt;finger andy@192.168.1.29

[192.168.1.29:79]
Login: andy                             Name: Andy Zhou
Directory: /home/andy                   Shell: /bin/sh
Office: 321, 777-888-9999
On since Thu May 29 12:08 (PST) on ttyp0 from MYWIN10-
No Plan.</code></pre></div><p data-pid="t2DOKoxZ">第一条命令直接 finger @&lt;服务器地址&gt; ，会列出服务器上所有用户名和登陆时间，第二条命令 finger &lt;用户名&gt;@&lt;服务器地址&gt; 则查询某个用户的详细信息。在互联网的洪荒时代，Finger曾起到过类似公司通讯录的作用，你可以轻易的找到你想联系的人，并给他发邮件。但很快这一协议就被滥用，成为社会工程攻击的入口，因此在90年代后期开始，越来越少服务器提供Finger服务，直到今天临近消失的状态。</p><h3>关于root密码的特别提示</h3><p data-pid="izdS1rzP">我本来想下一集再说，但因为SLS的密码系统有个大Bug，我必须先在这一集中提到。</p><p data-pid="y73zQ34C">SLS使用影子密码系统，即用户列表保存在/etc/shadow中，普通用户可以读取/etc/passwd，没有读取/etc/shadow的权限。但SLS的shadow文件中默认没有root用户，而passwd命令默认也不会创建这一信息，这就导致了当我们用passwd命令给root设置密码之后，root用户会被冻结而无法使用。</p><p data-pid="Z16N0yDG">为了避免这种情况，我们需要在为root设置密码前，提前在/etc/shadow中加入下面一行</p><div class="highlight"><pre><code class="language-text">root:*:0:0:99999:7::::</code></pre></div><p data-pid="v-WLGNgs">之后再设置密码，这一行就会变成</p><div class="highlight"><pre><code class="language-text">root:&lt;加密后的密码&gt;:0:0:99999:7::::</code></pre></div><p data-pid="ERa-0Dam">这样root用户才可以登录，如果你不小心把root用户锁住了，则需要在单用户模式下修改，在启动到LILO提示符时，按下Alt键，然后输入</p><div class="highlight"><pre><code class="language-text">linux single</code></pre></div><p data-pid="cSsHPof1">进入单用户模式，然后修复/etc/shadow中的内容，并重设密码，如果你把lilo.conf的delay一行删除或设置为0，可能会一闪而过，此时可以用安装系统时的a1启动盘启动，在出现LILO提示时按Alt，并输入</p><div class="highlight"><pre><code class="language-text">harddisk root=/dev/hda1 single</code></pre></div><p data-pid="2RNrTWwm">进入单用户模式，/dev/hda1是Linux的安装分区，如果你的分区不同，需要根据自己的情况进行调整。</p><h2>下集预告</h2><p data-pid="W7ITTElX">在下一集里，我们将在已经安装好的Linux 1.0服务器上启动WWW服务，配置X Window，并体验当时的Mosaic浏览器：<a href="https://zhuanlan.zhihu.com/p/700820663" class="internal">在中国接入互联网30周年之时，搭一台1994年的Linux服务器（中）</a></p></body></html>